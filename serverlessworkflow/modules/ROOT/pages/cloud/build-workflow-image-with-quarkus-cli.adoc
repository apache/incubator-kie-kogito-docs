Building Workflow Images locally with Quarkus CLI
=================================================
v1.0, 06-03-2022
:compat-mode!:
// Metadata:
:description: Build Serverless Application with Quarkus CLI
:keywords: kogito, workflow, quarkus, serverless, quarkus-cli
// links
:quarkus-kogito-examples: https://github.com/kiegroup/kogito-examples/tree/stable/kogito-quarkus-examples
:example-project: https://github.com/kiegroup/kogito-examples/tree/stable/kogito-quarkus-examples/serverless-workflow-greeting-quarkus
:quarkus-cli: https://quarkus.io/guides/cli-tooling
:quarkus-container-images: https://quarkus.io/guides/container-image
:quarkus-native-builds: https://quarkus.io/guides/building-native-image
:google-jib: https://github.com/GoogleContainerTools/jib


This guide will teach you how to build a Serverless Application Container Image using the {quarkus-cli}[Quarkus CLI].

== Pre Requisites

Before starting, make sure you have the needed dependencies installed.
We assume that you already have your Serverless Workflow application ready to be built inside
a container image for this tutorial. If not, you can follow the Getting Started xref:getting-started/create-your-first-workflow-service.adoc[guide], of use the example project we've use in this tutorial.

What will you need:

- Docker - recommended to use always the latest version.
    * It's not a problem if you don't have Docker installed or can't install it. {google-jib}[JiB] allows you to build container images without having the client tooling to build containers. However, Docker is required to build GraalVM native image using the Quarkus Native Builder image.

- {quarkus-cli}[Quarkus CLI] {quarkus_version}
- Java {java_min_version}
- Maven {maven_min_version}
- GraalVM {graalvm_min_version}: Note that, GraalVM is not a required dependency, if you don't have it installed you can use the Quarkus Native Builder image to perform a local build, however, it will require to have the Docker tool installed.


== Getting started

First, clone the {kogito-examples}[kogito-examples] repository and access the {example-project}[serverless-workflow-greeting-quarkus] example.

.Cloning Kogito Examples
[source,shell]
----
$ git clone --branch stable {kogito-examples} && kogito-examples/kogito-quarkus-examples/serverless-workflow-greeting-quarkus
----

If you wish to run the example beforehand, follow the steps described in the Getting Started guide.

With the example in place, let's visit {quarkus-cli}[Quarkus CLI], follow the installation instructions based on your preferred tool. Make sure you have the following Quarkus version installed:

=== Quarkus Container Extensions

At this point it is ssumed that you already have the Quarkus tooling installed, if not please visit: xref:getting-started/getting-familiar-with-our-tooling.adoc[Getting familiar with our tooling].

Quarkus provides a few extensions to build container images, like `JiB`, `docker`, `s2i`, and `buildpacks`.
For this guide, we use `JiB`. However, if you already use another extension or want to know how it works, please visit this {quarkus-container-images}[Quarkus' guide].

The Kogito Examples do not include the needed extensions. We will add it using the Quarkus CLI:


.Adding the JiB extension
[source,shell]
----
$ quarkus extension add 'container-image-jib'
----

If you inspect the pom.xml, you can check the newly added dependency.

.Checkin the JiB extension
[source,xml,subs="attributes+"]
----
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-container-image-jib</artifactId>
</dependency>
----

=== Building the Serverless Workflow Application

[source,shell]
----
$ quarkus build -Dquarkus.container-image.build=true \
    -Dquarkus.container-image.group=kogito \
    -Dquarkus.container-image.name=serverless-workflow-greeting-quarkus \
    -Dquarkus.container-image.tag=1.0 \
    -Dquarkus.container-image.registry=quay.io
----

Note that JiB caches the `target/lib` directory. Depending on how big your project is, it can speed up the rebuilds.
If you want to push it to a registry, make sure to set the following properties accordingly to your needs:

- quarkus.container-image.registry: registry address, e.g. _quay.io_.
- quarkus.container-image.group: registry _context/namespace_ or if on Kubernetes or OpenShift the _namespace/project_.
- quarkus.container-image.push: needs to be set to `true`, identify whether to push or not the image, defaults to `false`.

.Example on pushing the built Application to Quay.io
[source,shell]
----
$ quarkus build -Dquarkus.container-image.build=true \
    -Dquarkus.container-image.group=kogito \
    -Dquarkus.container-image.name=serverless-workflow-greeting-quarkus \
    -Dquarkus.container-image.tag=1.0 \
    -Dquarkus.container-image.registry=quay.io \
    -Dquarkus.container-image.push=true
----

The command above will result in the following container image: `quay.io/kogito/serverless-workflow-greeting-quarkus:1.0`.

Alternatively, you can create a maven profile to build the container image that can be triggered just by setting the target profile.

.Maven Profile Example
[source,xml]
----
<profile>
  <id>build-container</id>
  <properties>
    <quarkus.container-image.build>true</quarkus.container-image.build>
    <quarkus.container-image.group>kogito</quarkus.container-image.group>
    <quarkus.container-image.name>serverless-workflow-greeting-quarkus</quarkus.container-image.name>
    <quarkus.container-image.tag>1.0</quarkus.container-image.tag>
    <quarkus.container-image.registry>quay.io</quarkus.container-image.registry>
    <quarkus.container-image.push>true</quarkus.container-image.push>
  </properties>
</profile>
----

If using profiles, a new extension can be added to the target profile by setting profile name like the example below:

.Using Quarkus CLI with Maven profile
[source,shell]
----
$ quarkus build -- -Pbuild-container
----


==== Building the Serverless Workflow Application with Native Image

And what about native builds? When we talk about Serverless, we expect a small startup footprint that can be better when using Native Builds. Quarkus CLI allows you to do it by passing the _--native_ flag:

.Build Native Image
[source,shell]
----
$ quarkus build --native -Dquarkus.container-image.build=true \
    -Dquarkus.container-image.group=kogito \
    -Dquarkus.container-image.name=serverless-workflow-greeting-quarkus \
    -Dquarkus.container-image.tag=1.0-native \
    -Dquarkus.container-image.registry=quay.io \
    -Dquarkus.native.container-build=true
----

The command above will result in the following container image: `quay.io/kogito/serverless-workflow-greeting-quarkus:1.0-native`

If you don't have GraalVM installed, you can specify the _**quarkus.native.container-build=true**_ system properties. This property will create a Linux executable. Notice that, Native builds take longer than usual java builds. For more information about native builds please visit this {quarkus-native-builds}[guide].

=== Testing the built Container Image

If you do have Docker installed, Quarkus will push the image to Docker's local registry:

.JVM image
[source,shell]
----
$ docker run -it -p 8080:8080 quay.io/kogito/serverless-workflow-greeting-quarkus:1.0
...
INFO  [io.quarkus] (main) serverless-workflow-greeting-quarkus 1.22.1.Final on JVM (powered by Quarkus 2.9.2.Final) started in 1.302s
----

.Native Image
[source,shell]
----
$ docker run -it -p 8080:8080 quay.io/kogito/serverless-workflow-greeting-quarkus:1.0-native
...
INFO  [io.quarkus] (main) serverless-workflow-greeting-quarkus 1.22.1.Final native (powered by Quarkus 2.9.2.Final) started in 0.039s
----

Notice that the Native image startup is more than 1 second faster than the first one.
Let's invoke the application.

Having the image started, execute the following command:

[source,shell]
----
$ curl -X POST -H 'Content-Type:application/json' -H 'Accept:application/json' -d '{"workflowdata" : {"name": "John", "language": "English"}}' http://localhost:8080/jsongreet
----

Check to see if the response is similar to the following:
[source,json]
----
{
    "id": "2acf710d-7e4a-481d-925c-dfd85a369987",
    "workflowdata": {
        "name": "John",
        "language": "English",
        "greeting": "Hello from JSON Workflow, "
    }
}
----

=== What's Next?

- xref:cloud/deploying-on-minikube.adoc[Deploying Serverless Applications on Minikube]
- xref:cloud/deploying-on-kubernetes-cluster.adoc[Deploying Serverless Applications on Kubernetes].

include::../../pages/_common-content/report-issue.adoc[]