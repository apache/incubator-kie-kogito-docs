= Understanding JQ expressions

Every workflow instance is associated with a data model. This model regardless of whether your flow file is written in YAML or JSON, consists of a JSON object. The initial content of that object depends on how the flow is started. If the flow is created through a link:{cloud_events_url}[Cloud Event], then the content is taken from `data` property. If started through an HTTP POST invocation, then the request body is expected to have a `workflowdata` property, from where the content of the model is retrieved. 

Expressions are the mechanism defined by the link:{spec_doc_url}#workflow-expressions[Serverless Workflow Specification] for the states to interact with the data model. Kogito supports two expression languages: link:https://github.com/json-path/JsonPath[jsonpath] and link:https://stedolan.github.io/jq/manual/[jq]. The default one is `jq`, but you can change it to `jsonpath` by using the `expressionLang` property. This guide will focus on `jq` and discuss its usage in following uses cases: switch state conditions, action function arguments and  data filtering.


== Switch Conditions

Conditions inside a switch state allow the workflow designer to choose which path the flow should follow depending on the model content. A condition is an expression that returns a boolean when evaluated against the model. If the condition associated with a state transition returns true, that is the place for the flow to go. 

For example, in link:{kogito_sw_examples_url}/serverless-workflow-greeting-quarkus[greetings] repository, we are selecting which message should be displayed to the user depending on his language of choice: English or Spanish. In computational terms, if the value of the property language is English, the constant literal to be injected on the property message will be __Hello from__… , else if the value of the same property is Spanish, then the injected message will be __Saludos desde…__.

image::core/switch_condition.png[]

The switch state contains this condition, which in turn contains two `jq` expression that returns a boolean. 

[source,json]
----
"dataConditions": [
        {
          "condition": "${ .language == \"English\" }",
          "transition": "GreetInEnglish"
        },
        {
          "condition": "${ .language == \"Spanish\" }",
          "transition": "GreetInSpanish"
        }
      ]
----

As required by the specification, all expressions are embedded within `${… }`. But Kogito is smart enough to infer that the string within condition is an expression, so you can skip it and just write a shorter version of the previous code which behave the same. 

[source,json]
----
"dataConditions": [
        {
          "condition": ".language == \"English\"",
          "transition": "GreetInEnglish"
        },
        {
          "condition": ".language == \"Spanish\"",
          "transition": "GreetInSpanish"
        }
      ]
----

== Function Arguments

Serverless Workflow Specification allow defining link:{spec_doc_url}#workflow-functions[functions] that can be invoked several times by the states of the flow. Every different function call might contain different arguments, which are specified using function arguments.

A function definition can be found in the link:{kogito_sw_examples_url}/serverless-workflow-temperature-conversion[temperature conversion] repository. 
This flow performs xref:core/orchestration-of-openapi-based-services.adoc[OpenAPI] invocations to convert Fahrenheit to Celsius. 

We focus on the call to the  `substraction` one. 

[source,json]
----
"functions": [
{
  "name": "subtraction",
  "operation": "specs/subtraction.yaml#doOperation"
}]
----

Function arguments might be expressed as a JSON object, whose property values might be either a string containing an expression or any link:https://www.w3schools.com/js/js_json_datatypes.asp[JSON data type] (string, number, boolean…). 

[source,json]
----
"functionRef": 
{
  "refName": "subtraction",
  "arguments": 
  {
    "leftElement": ".fahrenheit",
    "rightElement": ".subtractValue"
  }
}
----

In the snippet above, we are specifying that the left number of the subtraction is equal to `fahrenheit` property (which is an input number provided by the user invoking the flow) and that the right number is equal to `substractvalue` property (which is a constant number injected into the flow model by SetConstants state). After resolving expression evaluation for all properties that contains an expression, the resulting JSON object is passed to the  OpenAPI call. Depending on the OpenAPI definition, properties of that JSON object will be used as body, path, query o header of the upcoming REST invocation. 
Note that, for the sake of brevity, the expression is not embedded within `${}`. Kogito will infer it is a valid `jq` expression because of the . prefix, but you can embed it if you prefer to do so.

Function arguments might also be defined as a string containing an expression that returns a JSON object.
[source,json]
----
"functionRef": {
  "refName": "subtraction",
  "arguments": "{leftElement: .fahrenheit, rightElement : .subtractValue}"
 }

----

In the snippet above, the whole string is evaluated and the resulting JSON object, which is the same than in the first case, is passed to the OpenAPI call. 

== Data filtering

Serverless workflow specification defines some filtering mechanisms in order to select which data should be part of the flow data model:
* link:{spec_doc_url}#action-data-filters[action data filter] selects the portion of the action result that will be merged into the model, overriding only those properties in the flow model that share the name with the selected action result
* link:{spec_doc_url}#state-data-filters[state data filter] sets the whole flow model to the JSON object returned by the expression, discarding any existing property.
* link:{spec_doc_url}#event-data-filters[event data filter]

We are going to illustrate, using this link:{kogito_sw_examples_url}/serverless-workflow-expression-quarkus[repository], the usage of action and state data filters.

image::core/expression_diagram.png[]

This Serverless Workflow Application accepts as input an array of complex numbers (where `x` is the real coordinate and `y` the imaginary one) and defines an expression function (invoked by `squareState`) to calculate the maximum `x` and the minimum `y` for that `numbers` array. It also contains an action data filter (defined inside `squareState`) that selects the maximum `x` to be merged into the flow model and a state data filter (defined inside `finish` state) that sets that max value as the whole model that will be returned to the caller.


.The expression function
[source,json]
----
"functions": [
    {
      "name": "max",
      "type": "expression",
      "operation": "{max: .numbers | max_by(.x), min: .numbers | min_by(.y)}"
    }
]
----

We define a `max` function of type expression. The operation property is a string containing a `jq` expression. This expression returns a JSON object, where the `max` property is the maximum value of the `x` coordinate in the input array, and the `min` property is the minimum value of the `y` coordinate in the same array. 

.The action data filter
[source,json]
----
"actions": [
        {
          "name": "maxAction",
          "functionRef": {
            "refName": "max"
          },
          "actionDataFilter": {
             "results" : ".max.x",
             "toStateData" : ".number"
          }
        }
 ]
----

Since we are only interested in the maximum `x`, besides invoking the function using `functionRef`, this action also contains an action data filter. If we were not adding this filter, the whole JSON object returned by the function call would be merged into the flow model. The filter has two properties: `results`, which selects the attribute to be merged from the data returned by the action, and `toStateData`, which indicates the name of the target property inside the flow model (in case this property does not exist, it will be added). So, after executing the action, the flow model will consist of a `number` property storing the maximum value and the original `numbers` array. Then the flow transitions to `finish` state.

.The state data filter
[source,json]
----
"name": "finish",
"type": "operation",
"stateDataFilter": {
   "input": "{result: .number}"
}
----

Since we do not want to return the original `numbers` array as a result of the flow execution, the final stage consists of a state data filter that sets the contents of the output model. Hence, we set the model to be a JSON object containing a property named `result`, whose value is the maximum number calculated by the previous state, which was stored in the `number` property. We achieve this by using the `input` property of the stateDataFilter construct, meaning that the model is changed before the state gets executed. As final result of this whole procedure, the  model content returned to the user contains a `result` property whose value is the maximum `x`.
