CNCF Serverless Workflow Specification Support
==============================================
v1.0, 06-08-2022
:compat-mode!:
// Metadata:
:description: CNCF Serverless Workflow Specification Support
:keywords: kogito, workflow, serverless, cncf, specification
// links
:quarkus-config-guide-url: https://quarkus.io/guides/config-reference


In this guide, you can learn the details about the Kogito implementation of the {spec_website_url}[CNCF Serverless Workflow] specification.

== Current Status

Currently, Kogito implements version {spec_doc_url}[{spec_version}] of the specification. The table below classifies the current implementation status for each specification feature. {spec_doc_url}#Retry-Definition[Retries] are the only feature that Kogito does not support yet.

.Current implementation status of the specification features
[cols="1,1,1"]
|===
| Feature | Status | Spec Reference

| <<states>>
| emoji:full_moon[]  
| {spec_doc_url}#workflow-states[Workflow States]

| <<functions>>
| emoji:last_quarter_moon[] 
| {spec_doc_url}#Function-Definition[Function Definition]

| <<events>>
| emoji:last_quarter_moon[] 
| {spec_doc_url}#Event-Definition[Event Definition]

| <<workflow_data>>
| emoji:full_moon[]  
| {spec_doc_url}#Workflow-Data[Workflow Data]

| <<expressions>>
| emoji:full_moon[] 
| {spec_doc_url}#Workflow-Expressions[Workflow Expressions]

| <<error_handling>>
| emoji:full_moon[] 
| {spec_doc_url}#Workflow-Error-Handling[Workflow Error Handling]

| <<retries>>
| emoji:construction[]
| {spec_doc_url}#Retry-Definition[Retry Definition]

| <<timeouts>>
| emoji:construction[]
| {spec_doc_url}#workflow-timeouts[Workflow Timeouts]

| <<compensation>>
| emoji:full_moon[]
| {spec_doc_url}#Workflow-Compensation[Workflow Compensation]

| <<constants>>
| emoji:full_moon[]
| {spec_doc_url}#workflow-constants[Workflow Constants]

| <<secrets>>
| emoji:full_moon[]
| {spec_doc_url}#workflow-secrets[Workflow Secrets]
|===

The following sections describe the current status of the supported features.

[#states]
=== Workflow Model - States

Kogito supports every state described in the specification {spec_version} version.

.Workflow States implementation status detail
[cols="1,1,1"]
|===
| State | Status | Spec Reference

| Event
| emoji:full_moon[] 
| {spec_doc_url}#Event-State[Event State]

| Operation
| emoji:full_moon[] 
| {spec_doc_url}#Operation-State[Operation State]

| Switch
| emoji:full_moon[] 
| {spec_doc_url}#Switch-State[Switch State]

| Delay
| emoji:full_moon[] 
| {spec_doc_url}#Delay-State[Delay State]

| Parallel
| emoji:full_moon[] 
| {spec_doc_url}#Parallel-State[Parallel State]

| Inject
| emoji:full_moon[] 
| {spec_doc_url}#Inject-State[Inject State]

| ForEach
| emoji:full_moon[]  
| {spec_doc_url}#ForEach-State[ForEach State]

| Callback
| emoji:full_moon[] 
| {spec_doc_url}#Callback-State[Callback State]
|===

[#functions]
=== Workflow Model - Functions

The table below illustrates the current status of the functions Kogito supports. 

For additional functions, the specification supports the `custom` type. Therefore, Kogito added support for `sysout` and `java` tyes. See <<func_sysout>> and <<func_java>> sections for more information.

.Workflow Functions implementation status detail
[cols="1,1,1"]
|===
| Function | Status | Spec Reference

| rest
| emoji:full_moon[]
| {spec_doc_url}#using-functions-for-restful-service-invocations[Using Functions for RESTful Service Invocations]

| rpc
| emoji:full_moon[]
| {spec_doc_url}#using-functions-for-rpc-service-invocations[Using Functions for RPC Service Invocations]

| expression
| emoji:full_moon[]
| {spec_doc_url}#using-functions-for-expression-evaluation[Using Functions for Expression Evaluation]

| asyncapi
| emoji:construction[]
| {spec_doc_url}#using-functions-for-async-api-service-invocations[Using Functions for Async API Service Invocations]

| graphql
| emoji:construction[]
| {spec_doc_url}#using-functions-for-graphql-service-invocations[Using Functions for GraphQL Service Invocations]

| odata
| emoji:construction[]
| {spec_doc_url}#using-functions-for-odata-service-invocations[Using Functions for OData Service Invocations]

| custom
| emoji:full_moon[]
| {spec_doc_url}#defining-custom-function-types[Defining custom function types]. Kogito supports `java` and `sysout` custom functions.
|===

[#func_sysout]
==== Sysout Custom Function

You can use this `custom` function type for debugging reasons or quick demonstrations:

.sysout function definition
[source,json]
----
{
  "functions": [
    {
      "name": "printMessage",
      "type": "custom",
      "operation": "sysout"
    }
  ]
}
----

Later in the `state` definition, you can call it this way:

.Example of a function reference within a state
[source,json]
----
{
  "states": [
    {
      "name": "myState",
      "type": "operation",
      "actions": [
        {
          "name": "printAction",
          "functionRef": {
            "refName": "printMessage",
            "arguments": {
              "message": "."
            }
          }
        }
      ]
    }
  ]
}
----

You should see the data output in the console.

[#func_java]
==== Java Custom Function

Kogito supports calling Java functions within the Maven project, in which you define the workflow. For example, you can declare your functions like this:

.Example of a Java function declaration
[source,json]
----
{
  "functions": [
    {
      "name": "myFunction", <1>
      "type": "custom", <2>
      "operation": "service:java:com.acme.MyInterfaceOrClass::myMethod" <3>
    }
  ]
}
----

1. The function name
2. The `custom` function type
3. The Kogito custom operation definition. `service` is the reserved operation keyword followed by the other keyword `java`. The next portion is the FQDN of the interface or implementation class, followed by the method name.

Your method's interface *must* receive a https://github.com/FasterXML/jackson[Jackson's] `JsonNode` object and return either `void` or another `JsonNode`. For example:

.Example of a Java function implementation
[source,java]
----
public class MyInterfaceOrClass {

    public void myMethod(JsonNode workflowData) {
        // do whatever I want with the JsonNode:
        // { "workflowdata": {} }
    }
    
    public JsonNode myMethod(JsonNode workflowData) {
        // do whatever I want with the JsonNode:
        // { "workflowdata": {} }
        // return the modified content:
        return workflowData;
    }
}
----

To call this function within your workflow, you can extract the JSON value you need via a xref:core/understanding-jq-expressions.adoc[`jq` expression] or pass it without any arguments. In this case, the caller sends the whole payload. For example:

.Example of a reference to a Java function in the Operation state
[source,json]
----
{
  "states": [
    {
      "name": "myState",
      "type": "operation",
      "actions": [
        {
          "name": "callJavaFunctionAction",
          "functionRef": {
            "refName": "myFunction"
          }
        }
      ]
    }
  ]
}
----

Alternatively, you can only pass the necessary data:

.Example of a reference to a Java function in the Operation state passing manipulated data
[source,json]
----
{
  "states": [
    {
      "name": "myState",
      "type": "operation",
      "actions": [
        {
          "name": "callJavaFunctionAction",
          "functionRef": {
            "refName": "myFunction",
            "arguments": {
              "data": "${ .my.expression.to.data }"
            }
          }
        }
      ]
    }
  ]
}
----

[#events]
=== Workflow Model - Events

Kogito supports the capabilities of the event according to the {spec_doc_url}#Event-Definition[specification defition of an event]. However, event `correlation` has limited support as per specification definition.

For more details about the event correlation feature that Kogito supports, see the guide xref:eventing/event-correlation-with-workflows.adoc[Event Correlation with Workflows].

[#workflow_data]
=== Workflow Data

Kogito has the full implementation of the data manipulation feature via either `jq` (default) or `jsonpath`.

JSON Path can have some limitations in specific scenarios, mainly when the use case requires complex data manipulation. See the {spec_doc_url}#workflow-data[Workflow Data] chapter in the specification.

Kogito also supports xref:core/state-data-filtering[data filtering]. For more information, check the section {spec_doc_url}#state-data-filters[State Data Filters] in the specification documentation.

[#expressions]
=== Expressions

Kogito supports either `jq` or `jsonpath` to define workflow expressions. As the {spec_doc_url}#workflow-expressions[specification defines], `jq` is the default expression language. If you want to use `jsonpath` instead, set the attribute `expressionLang` in the workflow definition:

.Example of changing the default expression language
[source,json]
----
{
  "id": "myworkflow",
  "version": "1.0",
  "expressionLang": "jsonpath",
  "name": "Workflow example",
  "description": "An example of how to use jsonpath expressions"
}
----

WARNING: using `jsonpath` is not recommended because of the limitations of the language for data manipulation. `jq` is more powerful, hence you can use it in a more variety of use cases. 

[#error_handling]
=== Error Handling

Kogito supports the error handling feature {spec_doc_url}#workflow-error-handling[according to the specification]. See the guide "xref:core/understanding-workflow-error-handling.adoc[Understanding Workflow Error Handling]" for more information.

[#retries]
=== Retries

Kogito hasn't implemented Retries yet, but it's in the projects' roadmap for the future versions.

Alternatively to Retries, you can use the xref:core/understanding-workflow-error-handling.adoc[error handling feature].

[#timeouts]
=== Workflow Timeouts

Kogito hasn't implemented workflows Timeouts yet, but it's in the projects' roadmap for the future versions.

[#compensation]
=== Compensantion

Kogito supports workflow compensation according to the {spec_doc_url}#Workflow-Compensation[specification definition]. The use case "xref:use-cases/orchestration-based-saga-pattern.adoc[Orchestration-based SAGA pattern]" guide has more details about compensations.

[#constants]
=== Workflow Constants

Kogito supports workflow constants according to the {spec_doc_url}#workflow-constants[specification definition].

[#secrets]
=== Workflow Secrets

Kogito supports workflow secrets according to the {spec_doc_url}#workflow-secrets[specification definition].

IMPORTANT: Secrets are tied to the {quarkus-config-guide-url}[Quarkus Configuration] module. Meaning that any form of configuration that Quarkus supports, it is also available in Kogito.

See the guide "xref:core/accessing-workflow-metainformation-in-runtime.adoc[Accessing Workflow Metainformation]" for more details.

== What's Next?

- xref:getting-started/cncf-serverless-workflow-specification-support.adoc[Creating your first Serverless Workflow service]
- xref:getting-started/getting-familiar-with-our-tooling.adoc[Getting familiar with our tooling].
