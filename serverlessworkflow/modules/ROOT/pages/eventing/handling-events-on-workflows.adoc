= Handling events on workflows

:compat-mode!:
// Metadata:
:description: Handling events on workflows
:keywords: kogito, workflow, serverless, event

This document describes Serverless Workflow link:{spec_doc_url}#Event-State[Event state]. Event state can be used to start a new workflow instance upon the reception of a designated link:{cloud_events_url}[CloudEvent] or to pause the execution of an existing workflow instance till a designated CloudEvent is received. 

== Event State match 

An Event state consist of one or more link:{spec_doc_url}#event-definition[event definitions]. Event definitions are combined to designate which CloudEvent Types the Event State should listen to. 

`onEvents` field contains an array of `eventRefs`, which is an array of event definition names, and a set of actions to be executed when there is a match. `exclusive` field is used to determine which CloudEvent types should be considered to determine if there is an event match. If `exclusive` value is false, all CloudEvent types should be received for a match to occur. Otherwise, the reception of any of the CloudEvent Types is consider a match. 

=== Event match example

Lets illustrate the usage of previously mentioned fields with an example

You can add two CloudEvent Types: `noisy` and `silent`

[source, json]
----
"events": [
    {
      "name": "noisyEvent",
      "source": "",
      "type": "noisy",
      "dataOnly" : "false"
    },
    {
      "name": "silentEvent",
      "source": "",
      "type": "silent"
    }
  ]
----

You want to indicate there is a match only when both a `noisy` and a `silent` CloudEvent types are received. You also want to execute a specific action for `noisy` and a different one for `silent`. You will indicate that by defining an Event state containing both event definitions in separate `onEvent` items and  setting `exclusive` to `false`.

[source, json]
----
  {
    "name": "waitForEvent",
    "type": "event",
    "onEvents": [
      {
        "eventRefs": [
          "noisyEvent"
         ],
         "actions": [ 
           {
             "functionRef": "letsGetLoud"
           }
         ]
      },
      {
        "eventRefs": [
           "silentEvent"
        ],
        "actions": [ 
          {
            "functionRef": "beQuiet"
          }
        ]
      }
    ]
    ,
    "exclusive": false
  }
----

If you want to execute the same action when both event types are received, you use just one `onEvent` item

[source, json]
----
  {
    "name": "waitForEvent",
    "type": "event",
    "onEvents": [
      {
        "eventRefs": [
          "noisyEvent",
          "silentEvent"
         ],
         "actions": [ 
           {
             "functionRef": "notCareAboutNoise"
           }
         ]
       }
    ]
    ,"exclusive": false
  }
----

If you want the same action to be executed when any of the event types are received, you set `exclusive` to true. You can also remove `exclusive`, since `true is the default value. 

[source, json]
----
  {
    "name": "waitForEvent",
    "type": "event",
    "onEvents": [
      {
        "eventRefs": [
          "noisyEvent",
          "silentEvent"
         ],
         "actions": [ 
           {
             "functionRef": "notCareAboutNoise"
           }
         ]
       }
    ]
    ,"exclusive": true
  }
----


== Starting a workflow instance

An event state can be used to start a new workflow instance. To enable this functionality, the `start` property in the workflow header should be set to the event state name. The workflow instance will be started when there is a an event match. 

Given the previously defined `waitForEvent` state, you set as starting event by adding following code at workflow header. 

[source,json]
----
"start":"waitForEvent"
----

== Resuming workflow execution

An Event state can be used to pause an existing workflow instance. When the Workflow execution reaches a non starting Event state, it pauses till there is an event match for that particular workflow instance. 

Similar to xref:working-with-callbacks.adoc[Callback state], the instance to be resumed is identified by `kogitoprocrefid` CloudEvent Attribute or calculated according to xref:event-correlation-with-workflows.adoc[Event Correlation] functionality. While callback state is used for _fire&wait_, event state covers _wait&fire_ scenarios.

== Additional resources

* xref:getting-started/create-your-first-workflow-service.adoc[Create your first Workflow Service].
* xref:consume-producing-events-with-kafka.adoc[Consuming and producing events with Kafka]
* xref:consume-producing-events-with-knative-eventing.adoc[Consuming and producing events with Knative]

include::../../pages/_common-content/report-issue.adoc[]

 