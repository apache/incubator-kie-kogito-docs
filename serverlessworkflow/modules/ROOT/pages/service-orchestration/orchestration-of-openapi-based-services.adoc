Orchestration of OpenAPI based services
=======================================
:compat-mode!:
// Metadata:
:description: Orchestration of OpenAPI based services
:keywords: kogito, workflow, serverless, openapi, services, json
// links:
:swagger_inspector_url: https://swagger.io/docs/swagger-inspector/how-to-create-an-openapi-definition-using-swagger/
:quarkus_swagger_url: https://quarkus.io/guides/openapi-swaggerui
:spring_swagger_url: https://springdoc.org/#Introduction
:go_swagger_url: https://goswagger.io/
:python_flasgger_url: https://github.com/flasgger/flasgger
:dotnet_swagger_url: https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0
:npm_swagger_url: https://www.npmjs.com/package/swagger-ui-express
:php_swagger_url: https://github.com/zircote/swagger-php
:quarkus_config_url: https://quarkus.io/guides/config-reference
:quarkus_rest_client_url: https://quarkus.io/guides/rest-client
:mp_config_env_vars_url: https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc#environment-variables-mapping-rules
// Referenced documentation pages.
:getting-familiar-with-our-tooling: xref:getting-started/getting-familiar-with-our-tooling.adoc
:create-your-first-workflow-service: xref:getting-started/create-your-first-workflow-service.adoc
:build-workflow-image-with-quarkus-cli: xref:cloud/build-workflow-image-with-quarkus-cli.adoc
:understanding-jq-expressions: xref:core/understanding-jq-expressions.adoc
:configuring-openapi-services-endpoints: xref:service-orchestration/configuring-openapi-services-endpoints.adoc
:camel-k-integration: xref:integrations/camel-k-integration.adoc
:authention-support-for-openapi-services: xref:security/authention-support-for-openapi-services.adoc

This document describes how to call REST services via an link:{open_api_spec_url}[OpenAPI] specification file.

The examples in this document assume that you have the Quarkus tooling installed and have created a Serverless Workflow project. 

For more information about the tooling, see {getting-familiar-with-our-tooling}[Using Serverless Workflow tooling]. To create a new project, see {create-your-first-workflow-service}[Creating your first Serverless Workflow service].

== The OpenAPI Function Definition

Kogito follows the link:{spec_doc_url}#using-functions-for-restful-service-invocations[CNCF Serverless Workflow specification function definition] to make calls to remote REST services using an OpenAPI specification reference, as shown in the following example:

.An example of an OpenAPI function definition
[source,json]
----
{
   "functions":[
      {
         "name":"myFunction1",
         "operation":"classpath:/myopenapi-file.yaml#myFunction1"
      }
   ]
}
----

The `operation` attribute is a string composed by:

1. The URI scheme that the engine uses to locate the specification file
2. The location path of the resource
3. The operation identifier (`operationId`), which you find in the link:{open_api_spec_url}#fixed-fields-7[OpenAPI specification file].

Kogito supports the following URI schemes:

* `classpath` for files located in the application project under the `src/main/resources` folder. The `classpath` is the default scheme when you don't define a scheme in the string. For example `classpath:/myopenapifile.yaml` or `/myopenapifile.yaml`. In this example, the file location is in `src/main/resources/myopenapifile.yaml` path
* `file` for files located in the filesystem
* `http` or `https` for remotely located files

[IMPORTANT]
====
The OpenAPI specification files must be available only on build time. This is because, during runtime, Kogito leverages its internal code generation feature to make the REST calls. So {build-workflow-image-with-quarkus-cli}[once you build your application image], the Kogito engine won't access the files anymore.
====

== Getting Access to the OpenAPI Specification Files

To get started, you must locate the REST services OpenAPI specification files.

Usually, REST services expose their interface via the OpenAPI specification. For example, see the link:https://petstore3.swagger.io/api/v3/openapi.json[Petstore API].

If the service you want to add to the workflow doesn't have the specification file, you can either create one or update the service to generate and expose it.

The vast majority of the popular REST frameworks already support the OpenAPI specification generator. For example:

* Java
** link:{quarkus_swagger_url}[Quarkus Swagger]
** link:{spring_swagger_url}[Spring Boot Docs]
* Go
** link:{go_swagger_url}[Go Swagger]
* Python
** link:{python_flasgger_url}[Flasgger]
* .NET
** link:{dotnet_swagger_url}[ASP.NET Core web API documentation with Swagger / OpenAPI]
* TypeScript
** link:{npm_swagger_url}[Swagger UI Express]
* PHP
** link:{php_swagger_url}[Swagger PHP]

If you don't have access to the REST service to add the OpenAPI specification generator, you can use the link:{swagger_inspector_url}[Swagger Inspector] to generate the file. This tool will generate the specification file based on HTTP traffic.

== Making REST Calls based on the OpenAPI Specification

To make REST calls using OpenAPI specification files, you must define the function references and then use these functions in the workflow states.

=== Defining the OpenAPI functions

Once you have access to the OpenAPI specification files, you can create the function definitions in the workflow. You can use the link:{kogito_examples_base_url}/serverless-workflow-temperature-conversion[serverless-workflow-temperature-conversion] example application as a reference.

.Procedure
Copy the OpenAPI specification files of the service(s) you want to invoke into your Kogito workflow service directory `src/main/resources/specs`. In this example, the multiplication and subtraction services.

The files were extracted from the running multiplication and subtraction services. They are regular REST Quarkus applications that expose their OpenAPI specification files via the link:{quarkus_swagger_url}[Quarkus Swagger extension].

The `operationId` is necessary to add a reference to the proper operation you want to make the REST invocation.

In the Multiplication REST Service OpenAPI specification, you can locate the `operationId` attribute in the `paths` section, as shown in the example:

.Location of the `operationId` attribute
[source,yaml]
----
openapi: 3.0.3
info:
  title: Generated API
  version: "1.0"
paths:
  /:
    post:
     operationId: doOperation <1>
     parameters:
        - in: header
          name: notUsed
          schema: 
            type: string
          required: false
     requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MultiplicationOperation'
     responses:
        "200":
          description: OK
          content: 
            application/json:
              schema: 
                type: object
                properties:
                  product:
                    format: float
                    type: number
components:
  schemas:
    MultiplicationOperation: <2>
      type: object
      properties:
        leftElement:
          format: float
          type: number
        rightElement:
          format: float
          type: number
----

<1> The `operationId` of the REST operation
<2> The data structure of the REST operation

Use the `operationId` to compose the final URI in the function definition as shown in the example:

.OpenAPI Functions definition in the Temperature Conversion example
[source,json]
----
{
   "functions": [
    {
      "name": "multiplication",
      "operation": "specs/multiplication.yaml#doOperation" <1>
    },
    {
      "name": "subtraction",
      "operation": "specs/subtraction.yaml#doOperation" <2>
    }
  ]
}
----

<1> The OpenAPI function definition of the multiplication function
<2> The OpenAPI function definition of the subtraction function

=== Acessing the Functions in the Workflow States

The next step is to use the function definitions in the workflow states. 

Any link:{spec_doc_url}#Action-Definition[workflow actions] can call a function definition, having a similar way of referencing the functions that you previously defined in the workflow.

To map the function's arguments, refer to the parameters described in the OpenAPI specification file, link:{open_api_spec_url}#operation-object[operations section]. In the following example, the parameters are part of the request body.

The Kogito engine will map the parameter naming according to the OpenAPI specification. Then, you can use {understanding-jq-expressions}[JQ expressions] to extract the payload data and map it to the required parameters.

In the example application, the functions are called sequentially in an link:{spec_doc_url}#operation-state[Operation State]:

[source,json]
----
{
   "states": [
    {
      "name": "SetConstants",
      "type": "inject",
      "data": {
        "subtractValue": 32.0,
        "multiplyValue": 0.5556
      },
      "transition": "Computation"
    },
    {
      "name": "Computation",
      "actionMode": "sequential",
      "type": "operation", <1>
      "actions": [
        {
          "name": "subtract",
          "functionRef": {
            "refName": "subtraction", <2> 
            "arguments": { <3>
              "leftElement": ".fahrenheit", 
              "rightElement": ".subtractValue" 
            }
          }
        },
        {
          "name": "multiply",
          "functionRef": {
            "refName": "multiplication", <4> 
            "arguments": { <5> 
               "leftElement": ".difference",
               "rightElement": ".multiplyValue"
            }
          }
        }
      ],
      "end": {
        "terminate": "true"
      }
    }
  ]
}
----

<1> The Operation State definition
<2> Reference to the `subtraction` function
<3> Definition of the `subtraction` function arguments
<4> Reference to the `multiplication` function
<5> Definition of the `multiplication` function arguments

For an example mapping parameters in the request path rather than in the body, see the PetStore API example:

.Petstore OpenAPI specification excerpt
[source,json]
----
{
  "/pet/{petId}": {
      "get": {
        "tags": [
          "pet"
        ],
        "summary": "Find pet by ID",
        "description": "Returns a single pet",
        "operationId": "getPetById",
        "parameters": [
          {
            "name": "petId",
            "in": "path",
            "description": "ID of pet to return",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ]
     }
  }
}
----

[NOTE]
====
Only the highlighted excerpt of the OpenAPI specification file is shown in this example.
====

In this example, only one parameter named `petId` goes in the path. In this case, this is what an invocation to this function looks like:

.Example of calling the PetStore function
[source,json]
----
{
  "name": "CallPetStore", <1>
  "actionMode": "sequential",
  "type": "operation",
  "actions": [
    {
      "name": "getPet",
      "functionRef": {
        "refName": "getPetById", <2> 
        "arguments": { <3>
          "petId": ".petId"
        }
      }
    }
  ]
}
----

[NOTE]
====
Only the highlighted excerpt of the workflow definition file is shown in this example.
====

<1> The state definition
<2> The function definition reference, assuming that you have a function definition named `getPetById` for the PetStore OpenAPI specification
<3> The arguments definition. In this example, Kogito will add the argument `petId` to the request path before making the call.

== Configuring the OpenAPI Services endpoint URL

Under the hood, Kogito uses the link:{quarkus_openapi_gen_url}[Quarkus OpenAPI Generator extension] and the link:{quarkus_rest_client_url}[Quarkus REST Client]. All the configurations are based on these two components backed up by link:{quarkus_config_url}[Quarkus Configuration].

To configure the endpoints, you must use the sanitized OpenAPI specification file name as the link:{quarkus_rest_client_url}#create-the-configuration[REST client configuration key]. For example, for a file named `subtraction.yaml`, the configuration key is `subtraction_yaml`.

[TIP]
====
For more information about how Kogito sanitizes the file name, see link:{mp_config_env_vars_url}[Environment Variables Mapping Rules]. The key must be a valid environment variable.
====

This configuration key is used on every property related to the Quarkus REST Client. For example, to configure the URL, you can use:

.Example of URL configuration
[source,properties]
----
quarkus.rest-client.subtraction_yaml.url=http://myserver.com
----

To avoid hardcoding the URL in the application properties you can use link:{quarkus_config_url}#with-environment-variables[environment variables substitution], as shown in the example:

.Example of URL configuration with Environment Variables
[source,properties]
----
quarkus.rest-client.subtraction_yaml.url=${SUBTRACTION_URL:http://myserver.com}
----

In this example, if the environment variable `SUBTRACTION_URL` is not found, the URL falls back to `http://myserver.com`. 

[TIP]
====
You can use this feature to configure the application in Kubernetes environments where the environment variable can be injected in application's pod.
====

In a future release, Kogito will have a Kubernetes Service Discovery feature. With this feature, you will point to a Kubernetes or Knative object you want to call and the engine will automatically configure the endpoints for you once you deploy it in the cluster.

For more information about endpoints and general configuration, please see {configuring-openapi-services-endpoints}[Configuring OpenAPI Services Endpoints]. 

== Additional resources

- {configuring-openapi-services-endpoints}[Configuring OpenAPI Services Endpoints]
- {camel-k-integration}[Camel K Integration]
- {authention-support-for-openapi-services}[Authentication Support for OpenAPI Services]

include::../../pages/_common-content/report-issue.adoc[]
