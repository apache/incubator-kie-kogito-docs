Mocking HTTP CloudEvents Sink with WireMock
===========================================
:compat-mode!:
// Metadata:
:description: Mocking HTTP CloudEvents sink with WireMock
:keywords: kogito, workflow, quarkus, serverless, test, integration, wiremock, cloudevents
// Referenced documentation pages.
:basic_integration_test_with_restassured_guide: xref:testing-and-troubleshooting/basic-integration-tests-with-restassured.adoc
:mocking_openapi_services_with_wiremock_guide: xref:testing-and-troubleshooting/mocking-opnapi-services-with-wiremock.adoc
:getting_started_create_first_workflow_guide: xref:getting-started/create-your-first-workflow-service.adoc
:consume-produce-events-with-knative-eventing_guide: xref:eventing/consume-produce-events-with-knative-eventing.adoc
:mocking_http_cloudevents_with_wiremock_test_class: xref:testing-and-troubleshooting/mocking-http-cloudevents-with-wiremock.adoc#ref-create_test_class
// External pages
:knative_sink_binding_overview_url: https://knative.dev/docs/eventing/sinks/
:knative_sink_binding_impl_url: https://knative.dev/docs/eventing/custom-event-source/sinkbinding/
:knative_eventing_components_url: https://knative.dev/docs/getting-started/first-broker/
:knative_eventing_url: https://knative.dev/docs/eventing/
:event_driven_architecture_url: https://en.wikipedia.org/wiki/Event-driven_architecture
:kogito_sw_order_processing_example_url: {kogito_sw_examples_url}/serverless-workflow-order-processing
:kogito_sw_order_processing_example_VerifyWorkflowExecutionIT_class_url: {kogito_sw_order_processing_example_url}/src/test/java/org/kie/kogito/examples/sw/orders/processing/VerifyWorkflowExecutionIT.java
:kogito_sw_order_processing_example_pom_url: {kogito_sw_order_processing_example_url}/pom.xml
:kogito_sw_order_processing_example_test_application_properties_url: {kogito_sw_order_processing_example_url}/src/test/resources/application.properties
:quarkus_testing_guide_url: https://quarkus.io/guides/getting-started-testing
:recap_of_http_based_testing_in_jvm_mode_url: {quarkus_testing_guide_url}#recap-of-http-based-testing-in-jvm-mode
:awaitility_url: http://www.awaitility.org/
:awaitility_class_url: https://javadoc.io/static/org.awaitility/awaitility/4.2.0/org/awaitility/Awaitility.html
:wiremockserver_class_url: https://javadoc.io/doc/com.github.tomakehurst/wiremock/latest/com/github/tomakehurst/wiremock/WireMockServer.html
:wiremock_url: https://wiremock.org/
:wiremock_verifying_url: {wiremock_url}/docs/verifying/

This document describes how to test your Serverless Workflow application that uses HTTP {cloud_events_url}[*CloudEvents*] and {knative_sink_binding_impl_url}[*Knative Sink Binding*].

The testing case followed in this document is based on the {kogito_sw_order_processing_example_url}[`serverless-workflow-order-processing`] example application.

[[sinkbinding-test-overview]]
== Overview of HTTP CloudEvents, Knative SinkBinding and testing
--
The application we want to test must be configured to use {knative_eventing_url}[*Knative Eventing*], using standard HTTP POST requests to send and receive events between event producers and {knative_sink_binding_overview_url}[*sinks*].
These events conform to the {cloud_events_url}[*CloudEvents*] specification, which enables creating, parsing, sending, and receiving events in any programming language.

When you create an event source, you can specify a {knative_sink_binding_overview_url}[*sink*] where events are sent to, from the source.
A {knative_sink_binding_overview_url}[*sink*] is an Addressable or a Callable resource that can receive incoming events from other resources.
Kubernetes Deployments, Services, Knative Services, Channels, and Brokers are all examples of sinks.
This guide covers the testing of the Knative Service configured as {knative_sink_binding_overview_url}[*sink*].

The purpose of this guide is to mock that service to verify if the Cloud Events are correctly received by the sink.
The {wiremock_url}[*WireMok*] framework will add the mocked server that will verify the different Cloud Events received by the sink in the Serverless Workflow service execution.
--

[[mocking_sink_binding]]
== Testing the application with {knative_sink_binding_impl_url}[*SinkBinding*]

.Prerequisites
* A completed Kogito Serverless Workflow application working. More information available in {getting_started_create_first_workflow_guide}[Creating your first Serverless Workflow service guide].
* Configure the workflow application to use HTTP CloudEvents with {knative_sink_binding_impl_url}[*SinkBinding*].
Follow {consume-produce-events-with-knative-eventing_guide}[Consume and produce events with Knative eventing guide]
to enable {event_driven_architecture_url}[event-driven architecture] in the application using {knative_eventing_url}[*Knative Eventing*].

=== Adding test dependencies
Add the needed test dependencies to Serverless Workflow's application `pom.xml`.

** HTTP based Testing in JVM mode dependencies: *quarkus-junit5* and *rest-assured*. More detailed in {recap_of_http_based_testing_in_jvm_mode_url}[Testing your application Quarkus guide].
** {wiremock_url}[WireMock] framework: *wiremock-jre8*. Allowing to mock the server that plays as the sink.
** {awaitility_url}[Awaitility]: *awaitility* used to express expectations of an asynchronous system.

.Application testing dependencies. See the example {kogito_sw_order_processing_example_pom_url}[`pom.xml`] for more details.
[source,xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-junit5</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>io.rest-assured</groupId>
    <artifactId>rest-assured</artifactId>
    <scope>test</scope>
</dependency>
<dependency>
  <groupId>com.github.tomakehurst</groupId>
  <artifactId>wiremock-jre8</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.awaitility</groupId>
  <artifactId>awaitility</artifactId>
  <scope>test</scope>
</dependency>
----

[[ref-create_test_class]]
=== Create the test class
Create a test class mocking the sink using WireMock The following excerpt explores the different elements that should compose it:
anchor:test_class_bookmark[]
.Test class example. The full class in  {kogito_sw_order_processing_example_VerifyWorkflowExecutionIT_class_url}[`VerifyWorkflowExecutionIT`].
[source,java]
----
@QuarkusTest<1>
public class VerifyWorkflowExecutionIT { <2>

    private static WireMockServer sink; <3>

    static { <4>
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
    }

    /**
     * Starts the "sink" server, which is the endpoint that will receive our produced events
     */
    @BeforeAll <5>
    public static void startSink() {
        sink = new WireMockServer(options().port(8181)); <6>
        sink.start(); <7>
        sink.stubFor(post("/").willReturn(aResponse().withBody("ok").withStatus(200))); <8>
    }

    @AfterAll <9>
    public static void stopSink() {
        if (sink != null) {
            sink.stop(); <10>
        }
    }

    @Test
    void processDomesticOrderUnderFraudEval() throws JsonProcessingException, InterruptedException {
        final ObjectMapper objectMapper = new ObjectMapper();
        final Order order = new Order();
        order.setId(UUID.randomUUID().toString());
        order.setDescription("iPhone 12");
        order.setTotal(1001);
        order.setCountry("US");

        given() <4>
                .header("ce-specversion", "1.0")
                .header("ce-id", order.getId())
                .header("ce-source", "/from/test")
                .header("ce-type", "orderEvent")
                .contentType(MediaType.APPLICATION_JSON)
                .body(objectMapper.writeValueAsString(order))
                .post("/")
                .then()
                .statusCode(200);

        await() <11>
                .atMost(60, SECONDS)
                .with().pollInterval(1, SECONDS)
                .untilAsserted(() -> {
                    sink.verify(2, postRequestedFor(urlEqualTo("/")).withRequestBody(containing(order.getId())));
                    sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"fraudEvaluation\"").and(containing("\"id\":\"" + order.getId() + "\""))));
                    sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"domesticShipping\"").and(containing("\"id\":\"" + order.getId() + "\""))));
                }); <12>
    }
}

----
<1> @QuarkusTest starts a Quarkus server for the whole lifetime of the tests execution run.
More details in {recap_of_http_based_testing_in_jvm_mode_url}[enable quarkus testing resources].
<2> The naming of the test would end with 'IT' to identify which test needs to be executed as an integration test.
<3> {wiremockserver_class_url}[WireMockServer] mocked server instance used for Sink Binding for testing.
<4> Used to test interactions with the application, more explained in the guide {basic_integration_test_with_restassured_guide}[Testing your Serverless Workflow application using REST Assured].
<5> `@BeforeAll` annotation used to signal that the annotated method should be executed before all the tests run.
<6> Creates the {wiremockserver_class_url}[WireMockServer] instance listening at the port passed as parameter and must match with the sink configuration.
<7> Start the server before the tests executed.
<8> Stub the mock API response. It accepts a MappingBuilder instance that we can use to build API mapping information such as URL, request parameters and body, headers, authorization etc.
<9> `@AfterAll` annotation used to signal that the annotated method should be executed after all the tests execution.
<10> Stop the server after all test execution.
<11> {awaitility_class_url}[`await()`] added to waiting for asynchronous operations.
<12> {wiremock_verifying_url}[`verify`] if the request has hit the mock API with the expected event content.

[NOTE]
====
It is very important to start the server before the tests execute, and stop the server after the tests finish.
We can reset the mock stubs in between the tests.
====


=== Configure the Quarkus test
The test application needs to be configured to use the WireMockServer as the sink.
The test {kogito_sw_order_processing_example_test_application_properties_url}[`application.properties`] file must contain the reference to the WireMockServer created.

.Test {kogito_sw_order_processing_example_test_application_properties_url}[`application.properties`] sink connection property
[source,properties]
----
mp.messaging.outgoing.kogito_outgoing_stream.url=http://0.0.0.0:8181 <1>
----
<1> The port needs to match with the one passed in the WireMockServer creation moment in the test class created.

=== Execute Testing

To run the tests execute the following command:
--
[source,shell]
----
mvn clean verify
----
--

=== Testing execution cycle example

The testing case followed in this document is based on the {kogito_sw_order_processing_example_url}[`serverless-workflow-order-processing`] example application.

The {kogito_sw_order_processing_example_url}[example] is composed by three workflows:

.Example Order Processing workflows
image::testing-and-troubleshooting/order-example-worflows.png[]

The main workflow process the incoming Order event and start a parallel state calling two subflows: Fraud Handling and Shipping Handling.
The workflow will end once **both** subflows end.

Fraud Handling will produce a new `FraudEvaluation` event if the order is above 1000 USD.
Any other system or service in the architecture can then read this event and react upon it, like canceling the order for example.

In parallel, regarding or not the order would need fraud evaluation, the workflow will produce events classifying the required Shipping service: International or Domestic.
For this example, domestic shipping is any order with address within US.

The event flow between components in the example application is shown in this diagram

.Example event flow between components
image::testing-and-troubleshooting/example-components-interaction.png[]

Here, how the testing components replicates these relationships to verify the events received by the sink

.Example testing events flow.
image::testing-and-troubleshooting/testing-eventing-sink.png[]]

Before the test execution, the WireMockServer will start listening to the configured port as the sink, listening the events produced by the workflows.
Every time the workflow produce an event to the sink, it will be received by the WireMockServer, and the test can verify the event content.

Focusing in the `processDomesticOrderUnderFraudEval` described in this guide {mocking_http_cloudevents_with_wiremock_test_class}[test class], the use case covered is the production of `fraudEvaluation` (`Total > 1000`) and `domesticShipping` (`country = "US")`.
The `Order Event` consumed by the `Order` Workflow, needs to match the requirements:

[source]
----
        final ObjectMapper objectMapper = new ObjectMapper();
        final Order order = new Order();
        order.setId(UUID.randomUUID().toString());
        order.setDescription("iPhone 12");
        order.setTotal(1001);
        order.setCountry("US");

        given()
                .header("ce-specversion", "1.0")
                .header("ce-id", order.getId())
                .header("ce-source", "/from/test")
                .header("ce-type", "orderEvent")
                .contentType(MediaType.APPLICATION_JSON)
                .body(objectMapper.writeValueAsString(order))
                .post("/")
                .then()
                .statusCode(200);
----

Now, the test needs to check the sink is receiving the expected events with:

[source]
----
        await()
                .atMost(60, SECONDS)
                .with().pollInterval(1, SECONDS)
                .untilAsserted(() -> {
                    sink.verify(2, postRequestedFor(urlEqualTo("/")).withRequestBody(containing(order.getId())));
                    sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"fraudEvaluation\"").and(containing("\"id\":\"" + order.getId() + "\""))));
                    sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"domesticShipping\"").and(containing("\"id\":\"" + order.getId() + "\""))));
                });
----

{awaitility_class_url}[`await()`] Allows the test to retry the validations until assert the verifications, or until the specified time expires (in this case after 60 seconds).

Checking if the sink (WireMockServer) receives two events for that order id with:
[source]
----
sink.verify(2, postRequestedFor(urlEqualTo("/")).withRequestBody(containing(order.getId())));
----

To check the content of the received events, perform these verifications on the `types`:
[source]
----
sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"fraudEvaluation\"").and(containing("\"id\":\"" + order.getId() + "\""))));
sink.verify(1, postRequestedFor(urlEqualTo("/")).withRequestBody(containing("\"type\":\"domesticShipping\"").and(containing("\"id\":\"" + order.getId() + "\""))));
----

After assert the validations on received events, the test ends with success and the used WireMockServer will stop.

== Additional resources

* {getting_started_create_first_workflow_guide}[Creating your first Serverless Workflow service]
* {basic_integration_test_with_restassured_guide}[Testing your Serverless Workflow application using REST Assured]
* {mocking_openapi_services_with_wiremock_guide}[Mocking OpenAPI services using WireMock]
* {quarkus_testing_guide_url}[Testing a Quarkus application]
* {knative_eventing_components_url}[Knative Eventing components interaction: Source, Trigger, Broker, and Sink]

include::../../pages/_common-content/report-issue.adoc[]
