= Serverless Workflow integration test with postgreSQL
==========================================================
:compat-mode!:
// Metadata:
:description: Serverless Workflow integration test with postgreSQL
:keywords: kogito, workflow, quarkus, serverless, quarkus-cli, test, integration, postgreSQL
// Referenced documentation pages.
:basic-integration-test-with-restassured: xref:testing-and-troubleshooting/basic-integration-tests-with-restassured.adoc
:mocking-opnapi-services-with-wiremock: xref:testing-and-troubleshooting/mocking-opnapi-services-with-wiremock.adoc
:mocking-http-cloudevents-with-wiremock: xref:testing-and-troubleshooting/mocking-http-cloudevents-with-wiremock.adoc
// External pages
:kogito_sw_examples_git_repo_url: https://github.com/kiegroup/kogito-examples.git
:quarkus_testing_guide: https://quarkus.io/guides/getting-started-testing
:quarkus_testing_guide_integration_test: https://quarkus.io/guides/getting-started-testing#quarkus-integration-test
:quarkus_testing_guide_test_resource: https://quarkus.io/guides/getting-started-testing#quarkus-test-resource

This document describes how to test your Serverless Workflow application integrated with PostgreSQL persistence.

[[integration-test-overview]]
== Overview of Quarkus Integration testing
The goal is to be able to launch and test the artifact produced by the Quarkus builds and verify its interaction
with a PostgreSQL database instance.

In order to simulate that scenario and verify the service behaviour, we are using different Quarkus annotations and tools
 that simplify this work like:

* *@QuarkusIntegrationTest* will be used to launch and test the artifact produced by the Serverless Workflow Quarkus build. For more
details see {quarkus_testing_guide_integration_test}[@QuarkusIntegrationTest] guide.
* *@QuarkusTestResource* allows us to define test resources that need to be started before running the test. For more details see
{quarkus_testing_guide_test_resource}[Starting services before the Quarkus application starts] guide.
* *Kogito-quarkus-test-utils* with some Kogito predefined testcontainers as the PostgreSQL one.

The testing case followed in this document is based on the `serverless-workflow-examples/serverless-workflow-newsletter-subscription` example application.
You can access this example application in {kogito_sw_examples_git_repo_url}[Kogito Examples] GitHub repository


[[creating-integration-test]]
== Creating the integration test with postgreSQL
Let's create the integration test for a specific Serverless Workflow with PostgresQL:

First, we need to include the dependency to kogito-quarkus-test-utils at the project pom.xml
--

.Dependencies in `pom.xml` file
[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-quarkus-test-utils</artifactId>
  <scope>test</scope>
</dependency>
----
--
This allows us to use predefined test resources such the one we need in this case for PostgreSQL: PostgreSqlQuarkusTestResource

[NOTE]
====
This test framework allows the use of predefined test resources like: KafkaQuarkusTestResource, KeycloakQuarkusTestResource that can be used to test
more complex scenarios
====

The next step would be to add the test annotations to the integration test resources

.Example integration test annotation
[source,java]
----
@QuarkusIntegrationTest <1>
@QuarkusTestResource(PostgreSqlQuarkusTestResource.class) <2>
class HelloTestIT {<3>

}
----

<1> Allows launch and test the artifact produced by the Quarkus build. Supports testing a jar (of whichever type), a native image or container image
<2> Add the reference to the predefined PostgreSqlQuarkusTestResource in kogito-quarkus-test-utils. The annotation
@QuarkusTestResource makes Quarkus run the corresponding QuarkusTestResourceLifecycleManager before any tests are run.
<3> The naming of the test would end with 'IT' to identify which test needs to be executed as an integration test.

Once the needed resources and annotation are specified, We can start testing the different interactions with the Serverless Workflow like it
 is explained in {basic-integration-test-with-restassured}[Testing your Serverless Workflow application using REST Assured].

[[Add-postgreSQL-test-resource]]
== PostgreSQL instance as test resource
The test are using PostgreSqlQuarkusTestResource to start the PostgresSQL instance. PostgreSqlQuarkusTestResource is a predefined test
 resource provided by kogito-quarkus-test-utils that starts a container with the PostgreSQL instance. That container has a full set of
 default configuration that are included in the integration test automatically

[NOTE]
====
As a test resource, it will run its QuarkusTestResourceLifecycleManager before the service tests are executed.
More related info in {quarkus_testing_guide_test_resource}[TESTING YOUR APPLICATION] Quarkus guide.
====

The container has a full set of default configuration, such as PostgreSQL docker image name, default user, default password,...
 all the needed configuration values to link the Serverless Workflow service with that instance are added automatically to the integration test.

.Properties added automatically by PostgreSqlQuarkusTestResource
[source, properties]
----
quarkus.datasource.reactive.url
quarkus.datasource.jdbc.url
quarkus.datasource.username
quarkus.datasource.password
----

[[Add-conditional-postgreSQL-test-resource]]
== Conditional PostgreSQL test resource

This test resource can be disabled by a configuration like it's done in the `serverless-workflow-examples/serverless-workflow-newsletter-subscription` example.
This allows us to reuse the same integration test with PostgreSQL enabled just for profiles with persistence enabled.
In order to achieve this resource activation we have created this local test resource:

.Conditional test resource creation
[source,java]
----
@QuarkusIntegrationTest
@QuarkusTestResource(SubscriptionResourceIT.ConditionalPostgreSqlQuarkusTestResource.class)
public class SubscriptionResourceIT {
    ...
    public static class ConditionalPostgreSqlQuarkusTestResource extends PostgreSqlQuarkusTestResource {

        public ConditionalPostgreSqlQuarkusTestResource() {
            enableConditional();
        }

        private boolean isEnabled() {
            return Optional.ofNullable(System.getProperty("enable.resource.postgresql")).map(property -> property.equalsIgnoreCase(Boolean.TRUE.toString())).orElse(false);
        }

        @Override
        protected Map<String, String> getProperties() {
            return isEnabled() ? super.getProperties() : new HashMap<>();
        }
    }
}
----

This new resource ConditionalPostgreSqlQuarkusTestResource only will be started when the 'enable.resource.postgresql' system property is true.
In the example, the `persistence` profile incorporates this property setting to execute the integration test with the
 ConditionalPostgreSqlQuarkusTestResource enabled.

.Example of profile definition that runs the integration test with ConditionalPostgreSqlQuarkusTestResource enabled
[source,xml]
----
 <profile>
   <id>persistence</id>
   <activation>
     <property>
       <name>persistence</name>
     </property>
   </activation>
   <properties>
     <quarkus.profile>persistence</quarkus.profile>
     <enable.resource.postgresql>true</enable.resource.postgresql>
     <quarkus.datasource.devservices.enabled>true</quarkus.datasource.devservices.enabled>
   </properties>
 </profile>
----

[[execute-integrationtest]]
== Execute integration test

To run the test with the PostgreSQLQuarkusTestResource enabled, execute the following command:

--
.Command to run a test
[source,shell]
----
mvn clean verify
----

Or in case of the Conditional Quarkus test resource and the `persistence` profile includes  `<enable.resource.postgresql>true</enable.resource.postgresql>`
.Command to run a test with an specific profile
[source,shell]
----
mvn clean verify -Ppersistence
----

or enabling directly throw the command line
.Command to run a test enabling the ConditionalPostgreSqlQuarkusTestResource through command line
[source,shell]
----
mvn clean verify -Denable.resource.postgresql=true
----

The testing procedure in this document is based on the `serverless-workflow-examples/serverless-workflow-newsletter-subscription`
 example application. You can access this example application in {kogito_sw_examples_git_repo_url}[Kogito Examples] GitHub repository

--

== Additional resources

* {basic-integration-test-with-restassured}[Testing your Serverless Workflow application using REST Assured]
//* {mocking-opnapi-services-with-wiremock}[Mocking OpenAPI services using WireMock]
//* {mocking-http-cloudevents-with-wiremock}[Mocking HTTP CloudEvents using WireMock]
* {quarkus_testing_guide}[Testing a Quarkus application]

include::../../pages/_common-content/report-issue.adoc[]
